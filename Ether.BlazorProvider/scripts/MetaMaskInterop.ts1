
// global metahmask window object
//declare var window;
const globalMetamask = (window as any).ethereum;

interface JsonRpcResponse {
    id: any,
    jsonrpc: string,
    result: any
    error : any
}

export class MetaMaskInterop {

    private _metaMaskApi: any;

    // a web3 provider with either a "request" or "sendAsync
    private _providerApi: any;

    private _logEnabled: boolean = true;

    constructor(metaMaskApi: any) {
        this._metaMaskApi = metaMaskApi;
    }

    get MetaMaskApi(): any { return this._metaMaskApi }

    isMetaMaskAvailable(): boolean {
        return this._metaMaskApi ? true : false
    }

    configureOnChange(dotNetReference: any) {
        if (this.isMetaMaskAvailable()) {

            this.MetaMaskApi.on("accountsChanged",
                function (accounts) {
                    dotNetReference.invokeMethodAsync('AccountChanged', accounts[0]);
                });

            this.MetaMaskApi.on("chainChanged",
                function (chainId) {
                    dotNetReference.invokeMethodAsync('ChainChanged', chainId.toString());
                });
        }

    }

    async connect() : Promise<string> {
        if (!this.isMetaMaskAvailable()) {
            throw "MetaMask is unavailable"
        }

        try {
            const address = await this.rpcRequestRequestAccounts();
            return address;
        } catch (error) {
            throw "Denied access"
        }
    }

    getAccounts(): Promise<string[]> {
        return this.rpcRequestAccounts();
    }

    getChainId(): Promise<string> {
        return this.rpcRequestChainId();
    }

    async rpcRequest(argsJson: any): Promise<string> {
        const args = JSON.parse(argsJson);
        const response: JsonRpcResponse = await this.metaMaskRequest(args);
        return JSON.stringify(response);
    }

    async sign(hexMessage: string): Promise<string> {
        const fromAddress = await this.rpcRequestRequestAccounts();
        const params = [hexMessage, fromAddress];
        const method = 'personal_sign';

        const response: JsonRpcResponse = await this.metaMaskRequest({ method, params });

        if (response.error !== null) throw response.error;

        return response.result;
    }

    //--

    private async rpcRequestRequestAccounts(): Promise<string> {

        const response: JsonRpcResponse = await this.metaMaskRequest({ method: 'eth_requestAccounts' });
        if (response.error !== null) throw response.error;
        return response.result[0];
    }

    private async rpcRequestAccounts(): Promise<string[]> {
        const response: JsonRpcResponse = await this.metaMaskRequest({ method: 'eth_accounts' });
        if (response.error !== null) throw response.error;

        const result: string[] = response.result;
        return result;
    }

    private async rpcRequestChainId(): Promise<string> {
        const response: JsonRpcResponse = await this.metaMaskRequest({ method: 'eth_chainId' });
        if (response.error !== null) throw response.error;

        const result: string = response.result;
        return result;
    }

    private async metaMaskRequest(args: any): Promise<JsonRpcResponse> {
        try {

            this.log(args);

            const response = await this._metaMaskApi.request(args);
            const rpcResponse = {
                jsonrpc: "2.0",
                result: response,
                id: args.id,
                error: null
            }

            this.log("request response:");
            this.log(rpcResponse);

            return rpcResponse;

        } catch (e) {
            this.log("Error:" + e);
            const rpcResonseError = {
                jsonrpc: "2.0",
                id: args.id,
                result: null,
                error: e
            }
            return rpcResonseError;
        }
    }

    private log(message: any) {
        if (this._logEnabled) {
            console.log(message);
        }
    }
}

export const MetaMaskInteropService: MetaMaskInterop = new MetaMaskInterop(globalMetamask);
